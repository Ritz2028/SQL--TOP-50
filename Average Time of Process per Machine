Average Time of Process per Machine

Example 1:

Input: 
Activity table:
+------------+------------+---------------+-----------+
| machine_id | process_id | activity_type | timestamp |
+------------+------------+---------------+-----------+
| 0          | 0          | start         | 0.712     |
| 0          | 0          | end           | 1.520     |
| 0          | 1          | start         | 3.140     |
| 0          | 1          | end           | 4.120     |
| 1          | 0          | start         | 0.550     |
| 1          | 0          | end           | 1.550     |
| 1          | 1          | start         | 0.430     |
| 1          | 1          | end           | 1.420     |
| 2          | 0          | start         | 4.100     |
| 2          | 0          | end           | 4.512     |
| 2          | 1          | start         | 2.500     |
| 2          | 1          | end           | 5.000     |
+------------+------------+---------------+-----------+
Output: 
+------------+-----------------+
| machine_id | processing_time |
+------------+-----------------+
| 0          | 0.894           |
| 1          | 0.995           |
| 2          | 1.456           |
+------------+-----------------+
Explanation: 
There are 3 machines running 2 processes each.
Machine 0's average time is ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894
Machine 1's average time is ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995
Machine 2's average time is ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456





What are we actually trying to do?

For each process on each machine, we want:

end timestamp ‚àí start timestamp

But the problem is:

start and end are in different rows

in the same table

So we need to pair the correct start row with the correct end row.

That pairing logic is the ON condition.

Look at ONE process only
Example: machine 0, process 0
machine_id	process_id	activity_type	timestamp
0	0	start	0.712
0	0	end	1.520

üëâ These two rows belong together.

So we must tell SQL:

‚ÄúMatch rows that belong to the same machine and the same process.‚Äù

Break the ON condition into pieces
1Ô∏è‚É£ a1.machine_id = a2.machine_id

Meaning in plain English:

Don‚Äôt mix rows from different machines.

Without this, machine 0‚Äôs start could match machine 1‚Äôs end ‚ùå.

2Ô∏è‚É£ a1.process_id = a2.process_id

Meaning:

Don‚Äôt mix different processes on the same machine.

Without this, process 0 start could match process 1 end ‚ùå.

3Ô∏è‚É£ a1.activity_type = 'start'

Meaning:

From the first copy of the table (a1), pick only start rows.

4Ô∏è‚É£ a2.activity_type = 'end'

Meaning:

From the second copy (a2), pick only end rows.

Put it together (FULL meaning)
ON a1.machine_id = a2.machine_id
AND a1.process_id = a2.process_id
AND a1.activity_type = 'start'
AND a2.activity_type = 'end'

üìå English translation:

‚ÄúJoin the start row and the end row that belong to the same process on the same machine.‚Äù

That‚Äôs it. Nothing more.

Visual: what SQL pairs internally
After applying the ON condition
a1.machine	a1.process	a1.type	a1.time	a2.type	a2.time
0	0	start	0.712	end	1.520
0	1	start	3.140	end	4.120
1	0	start	0.550	end	1.550
1	1	start	0.430	end	1.420
2	0	start	4.100	end	4.512
2	1	start	2.500	end	5.000
Why we don‚Äôt put this in WHERE

Because:

ON defines how rows are paired

WHERE filters after pairing

First we must pair correctly, then we can calculate.


SQL QUERY:
SELECT 
    a1.machine_id,
    ROUND(AVG(a2.timestamp - a1.timestamp), 3) AS processing_time
FROM Activity a1
JOIN Activity a2
    ON a1.machine_id = a2.machine_id
   AND a1.process_id = a2.process_id
   AND a1.activity_type = 'start'
   AND a2.activity_type = 'end'
GROUP BY a1.machine_id;
